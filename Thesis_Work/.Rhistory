pr.beta = dnorm(beta, mean = 0, sd = 1000, log = T)
pr.sd = dinvgamma(sd, 1, 1, log = T)
pr.theta = sum(pr.alpha, pr.beta, pr.sd)
return(pr.theta)
}
prior(param)
param
prior(c(0, 1, 1))
posterior <- function(param){
return (likelihood(param) + prior(param))
}
posterior(c(0, 1, 1))
prior(c(0, 1, 1))
likelihood(0, 1, 1)
likelihood(c(0, 1, 1))
rnorm(3, param, c(.1, .5, .3))
param
rnorm(1, param, c(.1, .5, .3))
rnorm(4, param, c(.1, .5, .3))
rnorm(5, param, c(.1, .5, .3))
diag(1,3,3)
diag(c(.1, .5, .3),3,3)
diag(c(.1, .5, .3),3,3)->cvmat
proposalfunction <- function(param){
return(mvrnorm(3, mean = param, sd= cvmat))
}
propose <- function(param){
return(mvrnorm(3, mean = param, sd= cvmat))
}
propose(param)
library(mvtnorm)
propose(param)
library(MASS)
propose(param)
mvrnorm(1, param, cvmat)
rnorm(3, param, c(.1, .5, .3))
cvmat = diag(c(.1, .5, .3). 3. 3)
cvmat = diag(c(.1, .5, .3). 3, 3)
cvmat = diag(c(.1, .5, .3), 3, 3)
cvmat
propose <- function(param){
return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))
}
propose(param)
array(cvmat)
array(dim=c(10, 3))
cvmat[1,]
runif(1)
runif(2)
runif(23)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
runif(1)
propose <- function(param){
return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))
}
run_metropolis_MCMC <- function(startval, iterations){
chain = array(dim = c(iterations+1,3))                # Structure of Array
chain[1,] = startval                              # Establish Loop
for (i in 1:iterations){
proposal = propose(chain[i,])   # Propose theta[i+1] based on theta[i]
accept = exp(posterior(proposal) - posterior(chain[i,]))
if (runif(1) < accept){     #AR <-Post(theta[i+1]) to Post(theta[i])
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,]
}
}
return(chain)
}
MCMC_MH <- function(startval, iterations){
chain = array(dim = c(iterations+1,3))                # Structure of Array
chain[1,] = startval                              # Establish Loop
for (i in 1:iterations){
proposal = propose(chain[i,])   # Propose theta[i+1] based on theta[i]
accept = exp(posterior(proposal) - posterior(chain[i,]))
if (runif(1) < accept){     #AR <-Post(theta[i+1]) to Post(theta[i])
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,]
}
}
return(chain)
}
startval = c(4,0,10)
chain = MCMC_MH(startval, 10000)
View(chain)
names(chain)<-c('Intercept', 'Beta.1', 'Sigma')
View(chain)
names(chain)
chain = MCMC_MH(startval, 10000)
rownames(chain) = c('Intercept', 'Beta1', 'Sigma')
dim(chain)
colnames(chain) = c('Intercept', 'Beta1', 'Sigma')
View(chain)
hist(chain[,1])
hist(chain[,2])
hist(chain[,3])
burnIn = 5000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
acceptance
par(mfrow=c(3,1))
hist(chain[,1])
hist(chain[,2])
hist(chain[,3])
par(mfrow=c(1,3))
hist(chain[,1])
hist(chain[,2])
hist(chain[,3])
hist(chain[,1])
hist(chain[,2])
hist(chain[,3])
hist(chain[,1], main = "Intercept Posterior")
hist(chain[,2], main = "Beta1 Posterior")
hist(chain[,3], main = "Sigma Posterior")
knitr::opts_chunk$set(echo = TRUE)
library(invgamma)
par(mfrow = c(2,3))
hist(chain[-(1:burnIn),1],nclass=30, , main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = trueA, col="red" )
par(mfrow = c(2,3))
hist(chain[-(1:burnIn),1],nclass=30, , main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true.alpha, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true.b, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),3]) )
abline(v = true.sd, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True value = red line" , main = "Chain values of a", )
abline(h = trueA, col="red" )
par(mfrow = c(2,3))
hist(chain[-(1:burnIn),1],nclass=30, , main="Posterior of a", xlab="True value = red line" )
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true.alpha, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior of b", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true.b, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior of sd", xlab="True value = red line")
abline(v = mean(chain[-(1:burnIn),3]) )
abline(v = true.sd, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True value = red line" , main = "Chain values of a", )
abline(h = true.alpha, col="red" )
plot(chain[-(1:burnIn),2], type = "l", xlab="True value = red line" , main = "Chain values of b", )
abline(h = true.b, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True value = red line" , main = "Chain values of sd", )
abline(h = true.sd, col="red" )
burnIn = 5000
?abline()
par(mfrow = c(2,3))
hist(chain[-(1:burnIn),1],nclass=30, main="Intercept Posterior", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true.alpha, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior Beta.1", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true.b, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior Sigma", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),3]) )
abline(v = true.sd, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True = red" , main = "Chain values of alpha", )
abline(h = true.alpha, col="red" )
plot(chain[-(1:burnIn),2], type = "l", xlab="True = red" , main = "Chain values of beta1", )
abline(h = true.b, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True = red" , main = "Chain values of sd", )
abline(h = true.sd, col="red" )
summary(lm(y~x))
## Not run:
### logistic regression
library("MASS")
data(birthwt)
y<- birthwt$lo
x<- data.frame(birthwt[,-1])
x$race<- as.factor(x$race)
x$ht<- (x$ht>=1)+0
x<- x[,-9]
x$smoke <- as.factor(x$smoke)
x$ptl<- as.factor(x$ptl)
x$ht <- as.factor(x$ht)
x$ui <- as.factor(x$ui)
library(BMA)
glm.out.FT <- bic.glm(x, y, strict = FALSE, OR = 20,
glm.family="binomial", factor.type=TRUE)
summary(glm.out.FT)
## Not run:
### Finney data
data(vaso)
x<- vaso[,1:2]
y<- vaso[,3]
n<- rep(1,times=length(y))
finney.models<- rbind(
c(1, 0),
c(0, 1),
c(1, 1))
finney.glib <- glib (x,y,n, error="binomial", link="logit",
models=finney.models, glimvar=TRUE,
output.priorvar=TRUE, output.postvar=TRUE)
summary(finney.glib)
predict(glm.out.FT, newdata = x)
data(birthwt)
y<- birthwt$lo
x<- data.frame(birthwt[,-1])
x$race<- as.factor(x$race)
x$ht<- (x$ht>=1)+0
x<- x[,-9]
x$smoke <- as.factor(x$smoke)
x$ptl<- as.factor(x$ptl)
x$ht <- as.factor(x$ht)
x$ui <- as.factor(x$ui)
glm.out.FT <- bic.glm(x, y, strict = FALSE, OR = 20,
glm.family="binomial", factor.type=TRUE)
predict(glm.out.FT, newdata = x)
plot(y~x)
bic.glm.bwT <- bic.glm(x, y, strict = FALSE, OR = 20,
glm.family="binomial",
factor.type=TRUE)
predict( bic.glm.bwT, newdata = x)
summary(bic.glm.bwT)
summary(bic.glm.bwT, conditional = T)
library(MASS)
data(Pima.tr)
# enumeration with default method="BAS"
pima.cch = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="BAS",
betaprior=CCH(a=1, b=532/2, s=0), family=binomial(),
modelprior=beta.binomial(1,1))
library(BAS)
install.packages("BAS")
install.packages("BAS")
library(BAS)
# enumeration with default method="BAS"
pima.cch = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="BAS",
betaprior=CCH(a=1, b=532/2, s=0), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.cch)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=5000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
pima.BIC = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="BAS+MCMC", MCMC.iterations=5000,
betaprior=bic.prior(), family=binomial(),
modelprior=uniform())
summary(pima.BIC)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="BAS+MCMC", MCMC.iterations=5000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
summary(glm.out.FT)
pima.robust$coefficients
summary(pima.robust)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=5000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
summary(pima.cch)
pima.cch$mle
pima.cch$mle->bob
dim(bob)
bob
pima.cch$se->bob
bob
pima.cch$mle.se
summary(pima.robust)
pima.cch$modelprior
pima.cch$betaprior
coef.bas(pima.cch)
coef(pima.cch)
predict(pima.robust, newdata = Pima.tr)
View(pima.tr)
View(Pima.tr)
predict(pima.robust, newdata = Pima.tr, type = 'response')
predict(pima.robust, newdata = Pima.tr, type = 'link')
predict(pima.robust, newdata=Pima.tr, type = 'response')
predict(pima.robust, newdata=Pima.tr, type = 'response')
fitted(pima.robust, newdata=Pima.tr)
fitted(pima.robust, newdata=Pima.tr, type = 'response')
library(MASS)
library(BAS)
data(Pima.tr)
# enumeration with default method="BAS"
pima.cch = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="BAS",
betaprior=CCH(a=1, b=532/2, s=0), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.cch)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=5000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=5000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=100000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
View(hr)
knitr::opts_chunk$set(echo = TRUE)
library(invgamma)
x <-hr$age
y <-  hr$annpay
plot(x,y, main="Test Data")
likelihood <- function(param){
alpha = param[1]
beta = param[2]
sd = param[3]
y.hat = alpha + beta*x
ind.LL = dnorm(y, mean = y.hat, sd = sd, log = T)
LL = sum(ind.LL)
return(LL)
}
# Example: plot the likelihood profile of the slope (beta)
beta.LLfun <- function(b){return(likelihood(c(true.alpha, b, true.sd)))}
beta.LLres <- lapply(seq(3, 7, by=.05), beta.LLfun )
plot (seq(3, 7, by=.05), beta.LLres , type="l", xlab = "beta values", ylab = "LL")
prior <- function(param){
alpha = param[1]
beta = param[2]
sd = param[3]
pr.alpha = dnorm(alpha, mean = 0, sd = 1000, log = T)
pr.beta = dnorm(beta, mean = 0, sd = 1000, log = T)
pr.sd = dinvgamma(sd, 1, 1, log = T)
pr.theta = sum(pr.alpha, pr.beta, pr.sd)
return(pr.theta)
}
posterior <- function(param){
return (likelihood(param) + prior(param))
}
propose <- function(param){
return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))
}
MCMC_MH <- function(startval, iterations){
chain = array(dim = c(iterations+1,3))                # Structure of Array
chain[1,] = startval                              # Establish Loop
for (i in 1:iterations){
proposal = propose(chain[i,])   # Propose theta[i+1] based on theta[i]
accept = exp(posterior(proposal) - posterior(chain[i,]))
if (runif(1) < accept){     #AR <-Post(theta[i+1]) to Post(theta[i])
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,]
}
}
return(chain)
}
startval = c(4,0,10)
chain = MCMC_MH(startval, 40000)
burnIn = 1000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
hist(chain[,1], main = "Intercept Posterior")
hist(chain[,2], main = "Beta1 Posterior")
hist(chain[,3], main = "Sigma Posterior")
lm(y~x)
library(rstanarm)
m1<-stan_glm(y~x)
print(m1)
bas.glm()
mean()
mean
bas.glm
knitr::opts_chunk$set(echo = TRUE)
library(invgamma)
true.b <- 5
true.alpha <- 0
true.sd <- 10
N <- 31
x <-(-15:15)
y <-  true.alpha + true.b * x + rnorm(n=N,mean=0,sd=true.sd)
plot(x,y, main="Test Data")
likelihood <- function(param){
alpha = param[1]
beta = param[2]
sd = param[3]
y.hat = alpha + beta*x
ind.LL = dnorm(y, mean = y.hat, sd = sd, log = T)
LL = sum(ind.LL)
return(LL)
}
# Example: plot the likelihood profile of the slope (beta)
beta.LLfun <- function(b){return(likelihood(c(true.alpha, b, true.sd)))}
beta.LLres <- lapply(seq(3, 7, by=.05), beta.LLfun )
plot (seq(3, 7, by=.05), beta.LLres , type="l", xlab = "beta values", ylab = "LL")
prior <- function(param){
alpha = param[1]
beta = param[2]
sd = param[3]
pr.alpha = dnorm(alpha, mean = 0, sd = 1000, log = T)
pr.beta = dnorm(beta, mean = 0, sd = 1000, log = T)
pr.sd = dinvgamma(sd, 1, 1, log = T)
pr.theta = sum(pr.alpha, pr.beta, pr.sd)
return(pr.theta)
}
posterior <- function(param){
return (likelihood(param) + prior(param))
}
propose <- function(param){
return(rnorm(3,mean = param, sd= c(0.1,0.5,0.3)))
}
MCMC_MH <- function(startval, iterations){
chain = array(dim = c(iterations+1,3))                # Structure of Array
chain[1,] = startval                              # Establish Loop
for (i in 1:iterations){
proposal = propose(chain[i,])   # Propose theta[i+1] based on theta[i]
accept = exp(posterior(proposal) - posterior(chain[i,]))
if (runif(1) < accept){     #AR <-Post(theta[i+1]) to Post(theta[i])
chain[i+1,] = proposal
}else{
chain[i+1,] = chain[i,]
}
}
return(chain)
}
startval = c(4,0,10)
chain = MCMC_MH(startval, 40000)
burnIn = 1000
acceptance = 1-mean(duplicated(chain[-(1:burnIn),]))
hist(chain[,1], main = "Intercept Posterior")
hist(chain[,2], main = "Beta1 Posterior")
hist(chain[,3], main = "Sigma Posterior")
par(mfrow = c(2,3))
hist(chain[-(1:burnIn),1],nclass=30, main="Intercept Posterior", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),1]))
abline(v = true.alpha, col="red" )
hist(chain[-(1:burnIn),2],nclass=30, main="Posterior Beta.1", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),2]))
abline(v = true.b, col="red" )
hist(chain[-(1:burnIn),3],nclass=30, main="Posterior Sigma", xlab="True = red")
abline(v = mean(chain[-(1:burnIn),3]) )
abline(v = true.sd, col="red" )
plot(chain[-(1:burnIn),1], type = "l", xlab="True = red" , main = "Chain values of alpha", )
abline(h = true.alpha, col="red" )
plot(chain[-(1:burnIn),2], type = "l", xlab="True = red" , main = "Chain values of beta1", )
abline(h = true.b, col="red" )
plot(chain[-(1:burnIn),3], type = "l", xlab="True = red" , main = "Chain values of sd", )
abline(h = true.sd, col="red" )
head(chain)
dim(chain)
mean(chain[,1])
mean(chain[,2])
var(chain[,2])
bas
bas.glm
library(BAS)
bas.glm
my_list <- list(lower=letters[1:4], upper=letters[-1:-20])
my_list['lower']
my_list[['lower']]
library(BAS)
bas.glm
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=10000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
hrbma<-bms(hr, mprior = 'uniform', burn = 20000, iter = 50000, user.int = FALSE)
library(BMS)
hrbma<-bms(hr, mprior = 'uniform', burn = 20000, iter = 50000, user.int = FALSE)
rint(hrbma)
print(hrbma)
pima.robust = bas.glm(type ~ ., data=Pima.tr, n.models= 2^7,
method="MCMC", MCMC.iterations=10000,
betaprior=robust(), family=binomial(),
modelprior=beta.binomial(1,1))
summary(pima.robust)
coef(pima.robust)
coef(pima.robust)[1]
confint(pima.robust)
pima.robust$postprobs
sum(pima.robust$postprobs)
pima.robust$priorprobs
pima.robust$freq
sum(pima.robust$freq)
pima.robust$which
pima.robust$postprobs.MCMC
pima.robust$model
pima.robust$xlevels
pima.robust$terms
pima.robust$call
pima.robust$X
pima.robust$Y
pima.robust$n.vars
pima.robust$include.always
pima.robust$n.models
pima.robust$betaprior
pima.robust$family
pima.robust$postprobs.RN
summary(pima.robust)
library(BAS)
pima.robust$mle
coef(pima.robust)
View(Pima.tr)
getwd()
var(c(10,8,6,4,2))
